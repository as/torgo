// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT

package screen

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return nil
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modGdi32    = windows.NewLazySystemDLL("Gdi32.dll")
	moduser32   = windows.NewLazySystemDLL("user32.dll")
	modkernel32 = windows.NewLazySystemDLL("kernel32.dll")

	procCreateCompatibleDC     = modGdi32.NewProc("CreateCompatibleDC")
	procSelectObject           = modGdi32.NewProc("SelectObject")
	procBitBlt                 = modGdi32.NewProc("BitBlt")
	procCreateCompatibleBitmap = modGdi32.NewProc("CreateCompatibleBitmap")
	procGetDC                  = moduser32.NewProc("GetDC")
	procGetObjectA             = modGdi32.NewProc("GetObjectA")
	procGetDIBits              = modGdi32.NewProc("GetDIBits")
	procGlobalAlloc            = modkernel32.NewProc("GlobalAlloc")
	procGlobalLock             = modkernel32.NewProc("GlobalLock")
	procGlobalUnlock           = modkernel32.NewProc("GlobalUnlock")
	procGlobalFree             = modkernel32.NewProc("GlobalFree")
	procGlobalSize             = modkernel32.NewProc("GlobalSize")
)

func CreateCompatibleDC(dc Handle) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procCreateCompatibleDC.Addr(), 1, uintptr(dc), 0, 0)
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SelectObject(handle Handle, in Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procSelectObject.Addr(), 2, uintptr(handle), uintptr(in), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func BitBlt(dst Handle, dx int, dy int, dw int, dh int, src Handle, sx int, sy int, rop uint32) (ok bool) {
	r0, _, _ := syscall.Syscall9(procBitBlt.Addr(), 9, uintptr(dst), uintptr(dx), uintptr(dy), uintptr(dw), uintptr(dh), uintptr(src), uintptr(sx), uintptr(sy), uintptr(rop))
	ok = r0 != 0
	return
}

func CreateCompatibleBitmap(dc Handle, w int, h int) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procCreateCompatibleBitmap.Addr(), 3, uintptr(dc), uintptr(w), uintptr(h))
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetDC(fd Handle) (handle Handle, err error) {
	r0, _, e1 := syscall.Syscall(procGetDC.Addr(), 1, uintptr(fd), 0, 0)
	handle = Handle(r0)
	if handle == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetObject(handle Handle, size int, in Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procGetObjectA.Addr(), 3, uintptr(handle), uintptr(size), uintptr(in))
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetDIBits(hdc Handle, hbmp Handle, sp uint32, n uint32, data uintptr, info uintptr, usage uint32) (err error) {
	r1, _, e1 := syscall.Syscall9(procGetDIBits.Addr(), 7, uintptr(hdc), uintptr(hbmp), uintptr(sp), uintptr(n), uintptr(data), uintptr(info), uintptr(usage), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GlobalAlloc(flag int, size int) (gh syscall.Handle, err error) {
	r0, _, e1 := syscall.Syscall(procGlobalAlloc.Addr(), 2, uintptr(flag), uintptr(size), 0)
	gh = syscall.Handle(r0)
	if gh == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GlobalLock(gh syscall.Handle) (h syscall.Handle, err error) {
	r0, _, e1 := syscall.Syscall(procGlobalLock.Addr(), 1, uintptr(gh), 0, 0)
	h = syscall.Handle(r0)
	if h == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GlobalUnlock(gh syscall.Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procGlobalUnlock.Addr(), 1, uintptr(gh), 0, 0)
	if r1 == uintptr(syscall.InvalidHandle) {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GlobalFree(gh syscall.Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procGlobalFree.Addr(), 1, uintptr(gh), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GlobalSize(gh syscall.Handle) (size int, err error) {
	r0, _, e1 := syscall.Syscall(procGlobalSize.Addr(), 1, uintptr(gh), 0, 0)
	size = int(r0)
	if size == 0 {
		if e1 != 0 {
			err = errnoErr(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}
