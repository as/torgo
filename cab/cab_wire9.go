// MACHINE GENERATED BY 'go generate' COMMAND
// TO EDIT A TYPE OR METHOD, COPY IT TO ANOTHER FILE IN THE PACKAGE
package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
)

func writestring(w io.Writer, s string, must int) (err error) {
	data := []byte(s)
	switch l := len(data); {
	case l > must:
		_, err = w.Write(data[:must])
	case l < must:
		_, err = w.Write(data[:l])
		if err != nil {
			return err
		}
		underflow := must - l
		_, err = w.Write(bytes.Repeat([]byte{0x00}, underflow))
	default:
		_, err = w.Write(data[:l])
	}
	return err
}

func ioErr(name, kind string, ac, ex int) error {
	return fmt.Errorf("%s: short %s: %d/%d", name, kind, ac, ex)
}

type block struct {
	crc   uint32
	zsize uint16
	size  uint16
	mshdr uint16
}

func (z *block) ReadBinary(r io.Reader) (err error) {
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.crc); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.zsize); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.size); err != nil {
		return err
	}

	if err := binary.Read(r, binary.LittleEndian, &z.mshdr); err != nil {
		return err
	}

	return nil
}

func (z block) WriteBinary(w io.Writer) (err error) {

	if err := binary.Write(w, binary.LittleEndian, z.crc); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.zsize); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.size); err != nil {
		return err
	}

	if err := binary.Write(w, binary.LittleEndian, z.mshdr); err != nil {
		return err
	}

	return nil
}
